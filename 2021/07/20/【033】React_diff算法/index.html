<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          React2.0_diff算法 - CXP的博客 | CXP&#39;s Blog
        
    </title>

    <link rel="canonical" href="http://yoursite.com/2021/07/20/【033】React_diff算法/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/hux-blog.min.css">


    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">CXP&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    

                    
                    

                    
                    <li>
                        <a href="/tags/tags.html">Tags</a>
                    </li>
                    
                    

                    
                    <li>
                        <a href="/archives/archive.html">Archives</a>
                    </li>
                    
                    

                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e) {
        if ($navbar.className.indexOf('in') > 0) {
            // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function () {
                // prevent frequently toggle
                if ($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            }, 400)
        } else {
            // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://yoursite.com/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#React" title="React">React</a>
                        
                    </div>
                    <h1>React2.0_diff算法</h1>
                    <h2 class="subheading">diff算法</h2>
                    <span class="meta">
                        Posted by Xiuping Chen on
                        2021-07-20
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="Diff的瓶颈以及React如何应对"><a href="#Diff的瓶颈以及React如何应对" class="headerlink" title="Diff的瓶颈以及React如何应对"></a>Diff的瓶颈以及React如何应对</h2><p>由于 Diff 操作本身也会带来性能损耗，React文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 O(n 3 )，其中 n 是树中元素的数量。</p>
<p>为了降低算法复杂度，React的diff会预设三个限制：</p>
<ol>
<li>只对同级元素进行Diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用他。</li>
<li>两个不同类型的元素会产生出不同的树。如果元素由<code>div</code>变为<code>p</code>，React会销毁<code>div</code>及其子孙节点，并新建<code>p</code>及其子孙节点。</li>
<li>开发者可以通过 <code>key</code>属性 来暗示哪些子元素在不同的渲染下能保持稳定</li>
</ol>
<h2 id="reconcileChildFibers"><a href="#reconcileChildFibers" class="headerlink" title="reconcileChildFibers"></a>reconcileChildFibers</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协调子节点，分为 mount 和 reconcile 2类</span></span><br><span class="line"><span class="comment">// mount用于首次渲染，child没有对应fiber，直接生成fiber，mount不会改变fiber的effectTag，原因见 appendAllChildren</span></span><br><span class="line"><span class="comment">// reconcile用于更新</span></span><br><span class="line"><span class="comment">// 根据newChild类型选择不同diff函数处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params">returnFiber, currentFirstChild, newChild, expirationTime</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// React.createElement类型 或者 子节点是String、Number对应的Array类型</span></span><br><span class="line">    <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">        <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(reconcileSingleElement(</span><br><span class="line">            returnFiber,</span><br><span class="line">            currentFirstChild,</span><br><span class="line">            newChild,</span><br><span class="line">            expirationTime</span><br><span class="line">          ))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在 beginWork update各类Component时并未处理HostText，这里处理单个HostText</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;number&#x27;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> placeSingleChild(reconcileSingleTextNode(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          newChild,</span><br><span class="line">          expirationTime</span><br><span class="line">        ))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在 beginWork update各类Component时并未处理HostText，这里处理多个HostText</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(newChild)) &#123;</span><br><span class="line">        <span class="keyword">return</span> reconcileChildrenArray(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          newChild,</span><br><span class="line">          expirationTime</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以上都没有命中，删除节点</span></span><br><span class="line">    <span class="keyword">return</span> deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> reconcileChildFibers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>newChild</code>参数就是本次更新的 JSX 对象（对应<code>ClassComponent</code>的<code>this.render</code>方法返回值，或者<code>FunctionComponent</code>执行的返回值）</p>
<ol>
<li>当<code>newChild</code>类型为<code>object</code>、<code>number</code>、<code>string</code>，代表同级只有一个节点 –&gt;  placeSingleChild</li>
<li>当<code>newChild</code>类型为<code>Array</code>，同级有多个节点    –&gt;  reconcileChildrenArray</li>
</ol>
<h2 id="placeSingleChild"><a href="#placeSingleChild" class="headerlink" title="placeSingleChild"></a>placeSingleChild</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标志当前fiber需要在commit阶段插入DOM</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">placeSingleChild</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// alternate存在表示该fiber已经插入到DOM</span></span><br><span class="line">  <span class="keyword">if</span> (shouldTrackSideEffects &amp;&amp; !fiber.alternate) &#123;</span><br><span class="line">    fiber.effectTag = Placement;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reconcileSingleTextNode"><a href="#reconcileSingleTextNode" class="headerlink" title="reconcileSingleTextNode"></a>reconcileSingleTextNode</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleTextNode</span>(<span class="params">returnFiber, currentFirstChild, textContent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略更新过程</span></span><br><span class="line">  <span class="keyword">const</span> created = createFiberFromText(textContent);</span><br><span class="line">  created.return = returnFiber;</span><br><span class="line">  <span class="keyword">return</span> created;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reconcileSingleElement"><a href="#reconcileSingleElement" class="headerlink" title="reconcileSingleElement"></a>reconcileSingleElement</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协调单一节点的子fiber 创建fiber</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleElement</span>(<span class="params">returnFiber, currentFirstChild, element, expirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line">  <span class="keyword">const</span> key = element.key;</span><br><span class="line">  <span class="comment">// 首先判断是否存在对应DOM节点</span></span><br><span class="line">  <span class="keyword">while</span> (child) &#123;</span><br><span class="line">    <span class="comment">// 上一次更新存在DOM节点，接下来判断是否可复用,比较key是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (child.key === key) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.type === element.type) &#123;</span><br><span class="line">        <span class="comment">// key相同后再看type是否相同, 如果相同则表示可以复用</span></span><br><span class="line">        <span class="comment">// 父级下应该只有这一个子节点，将该子节点的兄弟节点删除</span></span><br><span class="line">        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);</span><br><span class="line">        <span class="comment">// 创建child的workInProgress</span></span><br><span class="line">        <span class="keyword">const</span> existing = useFiber(child, element.props);</span><br><span class="line">        existing.return = returnFiber;</span><br><span class="line">        <span class="keyword">return</span> existing;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//  key不同或type不同都代表不能复用，会到这里</span></span><br><span class="line">      	<span class="comment">//  不能复用的节点，被标记为删除, 会标志传入的Fiber节点以及他的所有sibling节点为删除</span></span><br><span class="line">        deleteRemainingChildren(returnFiber, child);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 标记单一Fiber为删除</span></span><br><span class="line">      deleteChild(returnFiber, child);</span><br><span class="line">    &#125;</span><br><span class="line">    child = child.sibling;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建新Fiber，并返回</span></span><br><span class="line">  <span class="keyword">const</span> created = createFiberFromElement(element, expirationTime);</span><br><span class="line">  created.return = returnFiber;</span><br><span class="line">  <span class="keyword">return</span> created;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reconcileChildrenArray"><a href="#reconcileChildrenArray" class="headerlink" title="reconcileChildrenArray"></a>reconcileChildrenArray</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildrenArray</span>(<span class="params">returnFiber, currentFirstChild, newChildren, expirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 由于fiber没有保存before引用，所以无法通过头尾双指针的方式优化diff算法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// diff完成后新的第一个child</span></span><br><span class="line">  <span class="keyword">let</span> resultingFirstChild = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> previousNewFiber = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 可复用节点的位置可能和上次不同（需要标记Placement代表移动） ex： abcd =&gt; badc</span></span><br><span class="line">  <span class="comment">// 所以判断完是否可复用后还需要比较index，具体逻辑见 placeChild</span></span><br><span class="line">  <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 遍历到的newChild 索引</span></span><br><span class="line">  <span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 遍历过程中用于比较的老fiber</span></span><br><span class="line">  <span class="keyword">let</span> oldFiber = currentFirstChild;</span><br><span class="line">  <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一轮遍历，对比oldFiber与newChildren[i]寻找可以复用的fiber，可复用条件：</span></span><br><span class="line">  <span class="comment">// 1. 新旧节点都为文本节点，直接复用（文本节点没有key）</span></span><br><span class="line">  <span class="comment">// 2. 其他类型节点判断key是否相同决定复用（可能key相同但是类型不同）</span></span><br><span class="line">  <span class="comment">// 这次遍历要求新旧fiber key相同，顺序相同，如果遇到不满足的则跳出这次遍历</span></span><br><span class="line">  <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldFiber.index &gt; newIdx) &#123;</span><br><span class="line">      <span class="comment">// fiber.index 始终等于该fiber在数组中的索引，即使其前一个兄弟节点是null</span></span><br><span class="line">      <span class="comment">// ex： [null, a] ， 其中 a.index === 1</span></span><br><span class="line">      <span class="comment">// 上次的索引大于这次，代表上次这个节点之前的兄弟节点有null  ex： [null, a] </span></span><br><span class="line">      <span class="comment">// 假设这次是 [b, a] ，则实际上 diff的是 null -&gt; b   a -&gt; a</span></span><br><span class="line">      <span class="comment">// 所以这里这么赋值</span></span><br><span class="line">      nextOldFiber = oldFiber;</span><br><span class="line">      oldFiber = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextOldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key相同则更新fiber</span></span><br><span class="line">    <span class="comment">//   更新包括 复用fiber或者创建新fiber</span></span><br><span class="line">    <span class="comment">// key不同则返回null，代表该节点不能复用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试复用节点</span></span><br><span class="line">    <span class="keyword">const</span> newFiber = updateSlot(</span><br><span class="line">      returnFiber,</span><br><span class="line">      oldFiber,</span><br><span class="line">      newChildren[newIdx],</span><br><span class="line">      expirationTime</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 该索引对应位置的新节点是 null</span></span><br><span class="line">      <span class="keyword">if</span> (!oldFiber) &#123;</span><br><span class="line">        oldFiber = nextOldFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldFiber &amp;&amp; !newFiber.alternate) &#123;</span><br><span class="line">        <span class="comment">// oldFiber与newFiber都存在代表对应索引key没变化</span></span><br><span class="line">        <span class="comment">// !newFiber.alternate代表newFiber是新创建的fiber</span></span><br><span class="line">        <span class="comment">//   ex：oldFiber: &lt;div key=&quot;1&quot;&gt;&lt;/div&gt; newFiber: &lt;p key=&quot;1&quot;&gt;&lt;/p&gt;</span></span><br><span class="line">        <span class="comment">//   新旧fiber key相同，则newFiber存在，但是type不同，所以是创建新fiber，没有对应alternate</span></span><br><span class="line">        <span class="comment">// 插入新DOM节点的同时删掉老的DOM节点</span></span><br><span class="line">        deleteChild(returnFiber, oldFiber);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将可复用的新fiber插入，返回插入的索引</span></span><br><span class="line">    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!previousNewFiber) &#123;</span><br><span class="line">      <span class="comment">// 这是第一个插入的新fiber</span></span><br><span class="line">      resultingFirstChild = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      previousNewFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    previousNewFiber = newFiber;</span><br><span class="line">    oldFiber = nextOldFiber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二轮遍历情况1 newChildren遍历完时</span></span><br><span class="line">  <span class="keyword">if</span> (newIdx === newChildren.length) &#123;</span><br><span class="line">    <span class="comment">// 当newChildren遍历完时，代表第一轮所有新节点都可复用，</span></span><br><span class="line">    <span class="comment">// 只需要删除剩下的oldFiber，因为这部分oldFiber在新的数组里已经不存在了</span></span><br><span class="line">    deleteRemainingChildren(returnFiber, oldFiber);</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第二轮遍历情况2 oldFiber遍历完时</span></span><br><span class="line">  <span class="keyword">if</span> (!oldFiber) &#123;</span><br><span class="line">    <span class="comment">// 当oldFiber遍历完时，代表所有oldFiber已经复用完或者这是首次渲染没有oldFiber</span></span><br><span class="line">    <span class="comment">// 再遍历newChildren，把新节点append到后面，这部分在oldFiber中不存在的节点是新加入的</span></span><br><span class="line">    <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="keyword">const</span> newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);</span><br><span class="line">      <span class="keyword">if</span> (!newFiber) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二轮遍历情况3 newChildren，oldFiber都未遍历完</span></span><br><span class="line">  <span class="comment">// 将可复用的节点移动位置</span></span><br><span class="line">  <span class="comment">// 将所有未遍历的oldFiber存入map，这样在接下来的遍历中能O(1)的复杂度就能通过key找到对应的oldFiber</span></span><br><span class="line">  <span class="keyword">const</span> existingChildren = mapRemainingChildren(returnFiber, oldFiber);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">    <span class="keyword">const</span> newFiber = updateFromMap(</span><br><span class="line">      existingChildren,</span><br><span class="line">      returnFiber,</span><br><span class="line">      newIdx,</span><br><span class="line">      newChildren[newIdx],</span><br><span class="line">      expirationTime</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (newFiber) &#123;</span><br><span class="line">      <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newFiber.alternate) &#123;</span><br><span class="line">          <span class="comment">// 存在current，代表我们需要复用这个节点，将对应oldFiber从map中删除</span></span><br><span class="line">          <span class="comment">// 这样该oldFiber就不会置为删除</span></span><br><span class="line">          existingChildren.delete(newFiber.key === <span class="literal">null</span> ? newIdx : newFiber.key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="keyword">if</span> (!previousNewFiber) &#123;</span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">    <span class="comment">// 还留下的oldFiber表示没有被复用，需要删除</span></span><br><span class="line">    existingChildren.forEach(<span class="function"><span class="params">child</span> =&gt;</span> deleteChild(returnFiber, child));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，在我们做数组相关的算法题时，经常使用双指针从数组头和尾同时遍历以提高效率，但是这里却不行。</p>
<p>虽然本次更新的JSX对象<code>newChildren</code>为数组形式，但是和<code>newChildren</code>中每个值进行比较的是上次更新的Fiber节点，Fiber节点的同级节点是由<code>sibling</code>指针链接形成的链表。</p>
<p>即 <code>newChildren[0]</code>与<code>oldFiber</code>比较，<code>newChildren[1]</code>与<code>oldFiber.sibling</code>比较。</p>
<p>单链表无法使用双指针，所以无法对算法使用双指针优化。</p>
<p>基于以上原因，Diff算法的整体逻辑会经历两轮遍历。</p>
<p>第一轮遍历：处理更新的节点。</p>
<p>第二轮遍历：处理剩下的不属于更新的节点。</p>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2021/07/21/【034】前端安全/" data-toggle="tooltip" data-placement="top" title="前端安全">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2021/07/19/【032】Vue2.0_diff算法/" data-toggle="tooltip" data-placement="top" title="Vue2.0_diff算法">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#React" title="React">React</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "Blog";
    var disqus_identifier = "http://yoursite.com/2021/07/20/%E3%80%90033%E3%80%91React_diff%E7%AE%97%E6%B3%95/";
    var disqus_url = "http://yoursite.com/2021/07/20/%E3%80%90033%E3%80%91React_diff%E7%AE%97%E6%B3%95/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; CXP&#39;s Blog 2021 
                    <br>
                    Theme by <a target="_blank" rel="noopener" href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a target="_blank" rel="noopener" href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://yoursite.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<!-- <img src="http://yoursite.com/img/icon_wechat.png" width="0" height="0" /> -->
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
